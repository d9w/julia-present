\section{Tutorial}
\begin{frame}
	\frametitle{A brief Julia tutorial}
  \begin{itemize}
    \item A small taste of Julia's cool features
    \item Personal introduction to Julia assuming background in programming
    \item Many other resources online
    \item http://docs.julialang.org/
    \item https://learnxinyminutes.com/docs/julia/
    \item https://github.com/chrisvoncsefalvay/learn-julia-the-hard-way
    \item https://juliabyexample.helpmanual.io/
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Types}
  \begin{tiny}
  \begin{minted}{julia}
julia> type Foo
           bar
           baz::Int
           qux::Float64
       end

julia> foo = Foo("Hello, world.", 23, 1.5)
Foo("Hello, world.",23,1.5)

julia> typeof(foo)
Foo

julia> Foo((), 23.5, 1)
ERROR: InexactError()
 in Foo(::Tuple{}, ::Float64, ::Int64) at ./none:2
 ...

julia> foo.qux = 2
2

julia> foo.bar = 1//2
1//2

julia> typeof(foo.bar)
Rational{Int64}
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Functions}
  \begin{tiny}
  \begin{minted}{julia}
julia> function add(x, y)
    println("x is $x and y is $y")
    x + y
end

julia> add(5, 6)
"x is 5 and y is 6"
11

# Compact assignment of functions
julia> f_add(x, y) = x + y

julia> f_add(3, 4)
7

julia> f_tuple(x, y) = x + y, x - y

julia> f_tuple(3, 4)
(7, -1)

julia> p1(a...) = +(1,a...)
p1 (generic function with 1 method)

julia> p1(1,2,3)
7
\end{minted}
\end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Multiple Dispatch}
  \begin{tiny}
  \begin{minted}{julia}
julia> f(x::Float64, y::Float64) = 2x + y;

julia> f(2.0, 3.0)
7.0

julia> f(2.0, 3)
ERROR: MethodError: no method matching f(::Float64, ::Int64)
Closest candidates are:
  f(::Float64, !Matched::Float64) at none:1
...

julia> f(x::Number, y::Number) = 2x - y;

julia> f(2.0, 3)
1.0

julia> methods(f)
# 2 methods for generic function "f":
f(x::Float64, y::Float64) at none:1
f(x::Number, y::Number) at none:1
  \end{minted}
  \end{tiny}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Multiple Dispatch}
  \begin{tiny}
  \begin{minted}{julia}
 julia> methods(+)
 # 166 methods for generic function "+":
 +(a::Float16, b::Float16) at float16.jl:136
 +(x::Float32, y::Float32) at float.jl:206
 +(x::Float64, y::Float64) at float.jl:207
 +(x::Bool, z::Complex{Bool}) at complex.jl:126
 +(x::Bool, y::Bool) at bool.jl:48
 +(x::Bool) at bool.jl:45
 +{T<:AbstractFloat}(x::Bool, y::T) at bool.jl:55
 +(x::Bool, z::Complex) at complex.jl:133
 +(x::Bool, A::AbstractArray{Bool,N<:Any}) at arraymath.jl:105
 +(x::Char, y::Integer) at char.jl:40
 +{T<:Union{Int128,Int16,Int32,Int64,Int8,UInt128,UInt16,UInt32,UInt64,UInt8}}(x::T, y::T) at int.jl:32
 +(z::Complex, w::Complex) at complex.jl:115
 +(z::Complex, x::Bool) at complex.jl:134
 +(x::Real, z::Complex{Bool}) at complex.jl:140
 +(x::Real, z::Complex) at complex.jl:152
 +(z::Complex, x::Real) at complex.jl:153
 +(x::Rational, y::Rational) at rational.jl:179
 ...
 +(a, b, c, xs...) at operators.jl:119
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Functions are a type}
  \begin{tiny}
  \begin{minted}{julia}
help?> map
  search: map map! mapfoldr mapfoldl mapslices mapreduce mapreducedim
  pmap Mmap lazymap TypeMapLevel TypeMapEntry

  map(f, c...) -> collection

  Transform collection c by applying f to each element.
  For multiple collection arguments, apply f elementwise.

julia> map((x) -> x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia> map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33

julia> double = x -> 2x
(::#3) (generic function with 1 method)

julia> zs = map(double, [1:5])
1-element Array{StepRange{Int64,Int64},1}:
 2:2:10
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions}
  \begin{tiny}
  \begin{minted}{julia}
julia> prog = "1 + 1"
"1 + 1"

julia> ex1 = parse(prog)
:(1 + 1)

julia> typeof(ex1)
Expr

julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)

julia> ex1 == ex2
true

julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
  typ: Any
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Macros}
  \begin{tiny}
  \begin{minted}{julia}
julia> macro sayhello()
    return :( println("Hello, world!") )
end

julia> @sayhello()
"Hello, world!"

julia> macro twostep(arg)
           println("I execute at parse time. The argument is: ", arg)

           return :(println("I execute at runtime. The argument is: ", $arg))
       end

julia> ex = macroexpand( :(@twostep :(1, 2, 3)) );
I execute at parse time. The argument is: :((1,2,3))

julia> typeof(ex)
Expr

julia> ex
:(println("I execute at runtime. The argument is: ",\$(Expr(:copyast, :(:((1,2,3)))))))

julia> eval(ex)
I execute at runtime. The argument is: (1,2,3)
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Modules}
  \begin{tiny}
  \begin{minted}{julia}
module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

importall OtherLib

export MyType, foo

type MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, "MyType $(a.x)")
end
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Modules}
  \begin{tiny}
  \begin{minted}{julia}
module Normal
include("mycode.jl")
end

module Testing
include("safe_operators.jl")
include("mycode.jl")
end
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Testing}
  \begin{tiny}
  \begin{minted}{julia}
julia> using Base.Test

julia> foo(x) = length(x)^2
foo (generic function with 1 method)

julia> @test foo("bar") == 9
Test Passed
  Expression: foo("bar") == 9
   Evaluated: 9 == 9

julia> @testset "Foo Tests" begin
           @test foo("a")   == 1
           @test foo("ab")  == 4
           @test foo("abc") == 9
       end
Test Summary: | Pass  Total
Foo Tests     |    3      3
  \end{minted}
  \end{tiny}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The real world}
  \begin{tiny}
  \begin{minted}{julia}
using DifferentialEquations

srand(100)

prob = prob_sde_additive
sol =solve(prob,dt=1/2^(3))
@test typeof(sol.alg) == SRIW1

sol =solve(prob,dt=1/2^(3),alg_hints=[:additive])
@test typeof(sol.alg) == SRA1
  \end{minted}
  \end{tiny}
  \vspace{5.0mm}
   https://github.com/JuliaDiffEq/DifferentialEquations.jl
\end{frame}
